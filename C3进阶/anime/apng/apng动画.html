<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
  </head>
  <body>
    <article>
      <section>
        APNG（Animated PNG）由 Mozilla 于 2004 年提出， 文件扩展名仍然是
        .png，但包含多个 PNG 帧，用来实现动画。 它兼容性较好——普通的 PNG
        解码器会只显示第一帧， 而支持 APNG 的浏览器或工具则可以播放完整动画。

        本质优化: 利用canvas技术, 让多张apng资源切换时,尽可能缓存数据buffer.
        • ✅ 首次播放： 正常执行 + 缓存构建
        • 🚀 重复播放： 减少 60-80% 的 getImageData 调用
        • 🧠 内存控制： 智能 LRU 清理，限制总内存使用
        • 📱 移动端优化： 针对性降低缓存阈值
      </section>
      <section>
        <!-- 生成apng的方式 -->
        # 安装 brew install apngasm
        <br>
        # 生成动画 apngasm output.apng frame1.png frame2.png frame3.png
        <br>
        # 使用 ffmpeg 视频转为apng ffmpeg -i input.mp4 -plays 0 output.apng
      </section>
    </article>
    <img id="img" src="../apng/test.png" alt="Animated PNG">
    <div></div>
    <style>
      div {
        width: 100px;
        height: 100px;
        background-image: url("../apng/test.png");
      }
    </style>

    <canvas id="c"></canvas>
    <script type="module">
      import parseAPNG from "https://cdn.jsdelivr.net/npm/apng-js@1.1.5/+esm";

      /*
      ! 提升apng的性能, 还是要借助canvas的三方库
      | 库名              | 特点                              | 安装方式                      |
| --------------- | ------------------------------- | ------------------------- |
| **apng-js**     | 原生 JS 实现，无依赖，支持 Canvas 渲染、暂停、重播 | `npm install apng-js`     |
| **apng-canvas** | 简化封装，自动加载 APNG 到 `<canvas>` 播放  | `npm install apng-canvas` |
| **upng-js**     | 主要是解码 PNG/APNG，性能很高，可自写播放器逻辑    | `npm install upng-js`     |
| **pixi-apng**   | 基于 Pixi.js，适合游戏或 UI 动画          | `npm install pixi-apng`   |

      */
      /*
        console.log("parseAPNG", parseAPNG.default);
    */
      const canvas = document.getElementById("c");
      canvas.width = 640;
      canvas.height = 540;
      canvas.style = "zoom: 0.75";
      const ctx = canvas.getContext("2d");

      function getImgBuffer(url) {
        return new Promise(async (resolve) => {
          const blob = await fetch(url).then((res) => res.blob());
          const reader = new FileReader();
          reader.readAsArrayBuffer(blob);
          reader.onload = () => {
            resolve(reader.result);
          };
        });
      }

      async function createApngPlayer(url, options = {}) {
        const imgBuffer = await getImgBuffer(url);
        const apng = parseAPNG.default(imgBuffer);
        console.log(apng);
        Object.keys(options).forEach((key) => {
          apng[key] = options[key];
        });
        const player = await apng.getPlayer(ctx);
        return player;
      }

      (async () => {
        const player1 = await createApngPlayer("./test.png", {
          numPlays: 1,
        }); // 设置图1的 numPlays 为1，让其只播放一次
        const player2 = await createApngPlayer("./test.png");
        player1.play(); // 图1播放
        player1.on("end", () => { // 监听图1的播放，当其播放完毕时，马上开始图2的播放
          player2.play();
        });
        setTimeout(() => {
          player2.stop()
        }, 3000);
      })();
    </script>
  </body>
</html>
